#!/usr/bin/env bash

# search-in-subs - search for words in subtitle files
# copyright (c) 2024  Alex Rogers (https://github.com/linguisticmind)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

declare -- version='0.3.6'

(:)

declare -- script_source=$(realpath -- "${BASH_SOURCE[0]}")
declare -- script_name="${script_source##*/}"
declare -- config_dir="${XDG_CONFIG_HOME:-$HOME/.config}"'/'"${script_source##*/}"
declare -- cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}"'/'"${script_source##*/}"
declare -- script_dir=$(dirname -- "$script_source")

shopt -s extglob globstar nullglob

function fstr {

  { type -P lua5.4 || type -P lua; } &> /dev/null && "$_" <(printf '%s' '

    if #arg == 0 then
      io.stderr:write("fstr: fstr <str> [<name> <replacement> ...]\n")
      io.stderr:write("version: 0.1.0\n")
      os.exit(1)
    end

    str, replacements = arg[1], {}

    for i = 2, #arg, 2 do replacements[arg[i]] =  arg[i + 1]:gsub("\\([\\%%:{}])", "%1") end

    function string:fstr_match()

      local name, fallback, override

      i, j = self:find("^%%[%w_]+")
      if i == nil then i, j = self:find("[^\\]%%[%w_]+"); if i ~= nil then i = i + 1 end end

      if i ~= nil then name = self:sub(i + 1, j) else

        if i == nil then i, j = self:gsub("\\[{}]", "__"):find("^%%%b{}") end
        if i == nil then i, j = self:gsub("\\[{}]", "__"):find("[^\\]%%%b{}"); if i ~= nil then i = i + 1 end end

        if i == nil then return false end

        local rest
        name, rest = self:sub(i + 2, j - 1):match("([%w_]+)(.*)")

        repeat
          local split = rest:find("[^\\]:")
          if rest:sub(2, 2) == "-" then
            fallback = rest:sub(3, split or #rest)
          elseif rest:sub(2, 2) == "+" then
            override = rest:sub(3, split or #rest)
          end
          if split ~= nil then rest = rest:sub(split + 1) else rest = "" end
        until rest == ""

      end

      replacement = override or replacements[name] or fallback

      if replacement ~= nil then return true else
        io.stderr:write("fstr: unable to replace %{" .. name .. "}\n")
        os.exit(1)
      end

    end

    while str:fstr_match() do
      str = str:sub(1, i - 1) .. replacement .. str:sub(j + 1)
    end

    str = str:gsub("\\([\\%%:{}])", "%1")

    print(str)

  ') "$@"

}

declare -- opts
opts=$(getopt -n "$script_name" -o 't:,v,V,i,I,j,J,q,Q,r,R,c,C,e,E,s,S,h,H,m,M,n,N,w,W,p,P,k,K,b:,a:,f::,d,D,y,Y,o,O,' -l 'search-term:,verbose,no-verbose,inverse,no-inverse,filenames-nly,no-filenames-only,quiet,no-quiet,regex,no-regex,match-case,no-match-case,exact-whitespace,no-exact-whitespace,stats,no-stats,stats-headers,stats-no-headers,stats-headers-compact,stats-headers-no-compact,stats-headers-file-numbers,stats-headers-no-file-numbers,stats-wrap-filenames,stats-no-wrap-filenames,edl-play,edl-no-play,edl-play-keep-temporary,edl-play-no-keep-temporary,edl-play-before:,edl-play-after:,edl-save:,edl-save-paths:,edl-save-mkdir,edl-save-no-mkdir,edl-save-overwrite,edl-save-no-overwrite,edl-ignore-missing,edl-no-ignore-missing,mpv-opts:,color::,no-color,help,version,config::,' -- "$@") || exit 1
eval set -- "$opts"
unset -v opts

# --- BEGIN config ---
declare -- conf_default_glob='*.srt'
declare -- conf_chapter_title=

declare -a opt_search_term=()
declare -- opt_verbose=
declare -- opt_inverse=
declare -- opt_filenames_only=
declare -- opt_quiet=
declare -- opt_regex=
declare -- opt_match_case=
declare -- opt_exact_whitespace=
declare -- opt_stats=
declare -- opt_stats_headers=1
declare -- opt_stats_headers_compact=
declare -- opt_stats_headers_file_numbers=1
declare -- opt_stats_wrap_filenames=1
declare -- opt_edl_play=
declare -- opt_edl_play_keep_temporary=
declare -- opt_edl_play_before=0
declare -- opt_edl_play_after=0
declare -- opt_edl_save=
declare -- opt_edl_save_paths='relative'
declare -- opt_edl_save_mkdir=
declare -- opt_edl_save_overwrite=
declare -- opt_edl_ignore_missing=1
declare -a opt_mpv_opts=()
declare -- optdata__mpv_opts__append=1
declare -- opt_color='auto'
# --- END config ---

declare -- opt_config

declare -- i
for (( i = 1; i <= $#; i++ )); do
  case ${!i} in
    --config ) : "$(( i + 1 ))"; test "${!_}" == 'none' && { opt_config="$_"; break; } ;;
    --no-config ) opt_config='none'; break ;;
    -- ) break ;;
  esac
done
unset -v i

declare -- config_file="$config_dir/config.bash"
[[ ! $opt_config == 'none' ]] && test -f "$config_file" && source "$_"

declare -- optc

while true; do
  case $1 in
    -t | --search-term ) opt_search_term+=("$2"); shift 2 ;;
    -v | --verbose ) opt_verbose=1; shift ;;
    -V | --no-verbose ) opt_verbose=; shift ;;
    -i | --inverse ) opt_inverse=1; shift ;;
    -I | --no-inverse ) opt_inverse=; shift ;;
    -j | --filenames-only ) opt_filenames_only=1; shift ;;
    -J | --no-filenames-only ) opt_filenames_only=; shift ;;
    -q | --quiet ) opt_quiet=1; shift ;;
    -Q | --no-quiet ) opt_quiet=; shift ;;
    -r | --regex ) opt_regex=1; shift ;;
    -R | --no-regex ) opt_regex=; shift ;;
    -c | --match-case ) opt_match_case=1; shift ;;
    -C | --no-match-case ) opt_match_case=; shift ;;
    -e | --exact-whitespace ) opt_exact_whitespace=1; shift ;;
    -E | --no-exact-whitespace ) opt_exact_whitespace=; shift ;;
    -s | --stats ) opt_stats=1; shift ;;
    -S | --no-stats ) opt_stats=; shift ;;
    -h | --stats-headers ) opt_stats_headers=1; shift ;;
    -H | --stats-no-headers ) opt_stats_headers=; shift ;;
    -m | --stats-headers-compact ) opt_stats_headers_compact=1; shift ;;
    -M | --stats-headers-no-compact ) opt_stats_headers_compact=; shift ;;
    -n | --stats-headers-file-numbers ) opt_stats_headers_file_numbers=1; shift ;;
    -N | --stats-headers-no-file-numbers ) opt_stats_headers_file_numbers=; shift ;;
    -w | --stats-wrap-filenames ) opt_stats_wrap_filenames=1; shift ;;
    -W | --stats-no-wrap-filenames ) opt_stats_wrap_filenames=; shift ;;
    -p | --edl-play ) opt_edl_play=1; shift ;;
    -P | --edl-no-play ) opt_edl_play=; shift ;;
    -k | --edl-play-keep-temporary ) opt_edl_play_keep_temporary=1; shift ;;
    -K | --edl-play-no-keep-temporary ) opt_edl_play_keep_temporary=; shift ;;
    -b | --edl-play-before ) opt_edl_play_before="$2"; shift 2 ;;
    -a | --edl-play-after ) opt_edl_play_after="$2"; shift 2 ;;
    -f | --edl-save ) opt_edl_save="$2"; shift 2 ;;
    --edl-save-paths ) opt_edl_save_paths="$2"; shift 2 ;;
    -d | --edl-save-mkdir ) opt_edl_save_mkdir=1; shift ;;
    -D | --edl-save-no-mkdir ) opt_edl_save_mkdir=; shift ;;
    -y | --edl-save-overwrite ) opt_edl_save_overwrite=1; shift ;;
    -Y | --edl-save-no-overwrite ) opt_edl_save_overwrite=; shift ;;
    -o | --edl-ignore-missing ) opt_edl_ignore_missing=1; shift ;;
    -O | --edl-no-ignore-missing ) opt_edl_ignore_missing=; shift ;;
    --mpv-opts )
      [[ $2 =~ ^(:{0,2})(.*)$ ]]
      case ${BASH_REMATCH[1]} in
        : ) optdata__mpv_opts__append= ;;
        :: ) optdata__mpv_opts__append=1 ;;
      esac
      [[ ! $optdata__mpv_opts__append ]] && opt_mpv_opts=()
      while read -rd '' arg; do
        opt_mpv_opts+=("$arg")
      done < <(<<<"${BASH_REMATCH[2]}" xargs printf '%s\0')
      shift 2
    ;;
    --color ) opt_color="${2:-auto}"; shift 2 ;;
    --no-color ) opt_color='never'; shift ;;
    --help ) { test -f "$script_dir"'/man/man1/'"$script_name"'.1' || test -f "$(man -w "$script_name" &> /dev/null)"; } && man "$_"; exit ;;
    --version ) printf '%s\n' "$version"; exit ;;
    --config ) optc="${optc:-$1}" opt_config="${2:-auto}"; shift 2 ;;
    --no-config ) optc="${optc:-$1}" opt_config='none'; shift ;;
    -- ) shift; break ;;
    * ) printf '%s\n' "Internal error: unable to parse argument ${1@Q}." >&2; exit 1 ;;
  esac
done

case $opt_color in
  always ) opt_color=1 ;;
  auto ) [[ -t 1 ]] && opt_color=1 || opt_color= ;;
  never ) opt_color= ;;
  * ) printf '%s\n' "${opt_color:+$'\x1b[31m'}[$script_name] Invalid argument to ${opt_color:+$'\x1b[1m'}--color${opt_color:+$'\x1b[22m'}: ${opt_color@Q}. Allowed values are 'always', ['auto'], 'never'.${opt_color:+$'\x1b[0m'}" >&2; exit 1 ;;
esac

function optdata__config__run {

  if [[ $# -eq 0 ]]; then set -- "$config_file"; fi

  function optdata__config__edit {
    "${VISUAL:-${EDITOR:-nano}}" -- "$1"
  }

  function optdata__config__generate {
    local -- sed_script
		IFS= read -rd '' sed_script <<- 'EOF'
			/^\s*#\s+---\s+BEGIN\s+config\s+---\s*$/ {
			  n
			  :a /^\s*#\s+---\s+END\s+config\s+---\s*$/ ! { H; n; b a }
			  z
			  x
			  s/^[\t\n\v\f\r ]*//
			  s/[\t\n\v\f\r ]*$//
			  s/[\t\v\f\r ]+$//gm
			  {
			    s/'/'\\''/g
			    s/.*/printf '%s' '&' | sed -E '\/=\\($\/ { n; :a \/^\\)$\/ ! { s\/^\/#\/; n; b a } }'/e
			  }
			  s/^[^#]/#&/gm
			  p
			  q
			}
			$ q 1
		EOF
    if [[ ! -d ${1%/*} ]]; then
      mkdir -p -- "${1%/*}" && printf '%s\n' "Created configuration directory ${_@Q}."
    fi
    printf '%s\n' "Generating configuration file ${1@Q}."
    sed -En -- "$sed_script" "$script_source" | 
      tee -- "$1" |
      if { type -P batcat || type -P bat; } > /dev/null; then
        "$_" \
          --no-config \
          --style=numbers \
          --paging=never \
          --language=bash \
          --color=never ${opt_color:+--color=always}
      else
        cat -n
      fi &&
        printf '%s\n' "Configuration file ${1@Q} successfully generated."
  }

  case $opt_config in
    auto )
      if [[ -f $1 ]]; then
        optdata__config__edit "$1"; exit
      else
        while read -ep "Configuration file ${1@Q} does not exist. Would you like to generate it? [Y/n] "; do
          case $REPLY in
            [Yy] | '' ) break ;;
            [Nn] ) exit 1 ;;
          esac
        done
        optdata__config__generate "$1"
        while read -ep "Would you like to open it in a text editor? [Y/n] "; do
          case $REPLY in
            [Yy] | '' ) break ;;
            [Nn] ) exit 1 ;;
          esac
        done
        optdata__config__edit "$1"
        exit
      fi
    ;;
    edit )
      if [[ -f $1 ]]; then
        optdata__config__edit "$1"; exit
      else
        printf '%s\n' "No configuration file ${1@Q} to edit. Use ‘--config=generate’ to generate one."
        exit 1
      fi
    ;;
    generate )
      if [[ -f $1 ]]; then
        while read -ep "Configuration file ${1@Q} already exists. Would you like to overwrite it? [y/N] "; do
          case $REPLY in
            [Yy] ) break ;;
            [Nn] | '' ) exit 1 ;;
          esac
        done
        optdata__config__generate "$1"
        exit
      else
        optdata__config__generate "$1"; exit
      fi
    ;;
    remove )
      if [[ -f $1 ]]; then
        while read -ep "Configuration file ${1@Q} will be deleted. Are you sure you want to proceed? [y/N] "; do
          case $REPLY in
            [Yy] ) break ;;
            [Nn] | '' ) exit 1 ;;
          esac
        done
        rm -- "$1" && printf '%s\n' "Deleted configuration file ${_@Q}."
        if (shopt -s dotglob nullglob; set -- "${1%/*}/"*; [[ $# -eq 0 ]]); then
          rmdir -- "${1%/*}" && printf '%s\n' "Deleted empty configuration directory ${_@Q}."
        fi
        exit
      else
        printf '%s\n' "Configuration file ${1@Q} does not exist."
        exit 1
      fi
    ;;
  esac

}

case $optc in
  --config | --no-config )
    case $opt_config in
      auto | edit | generate | remove ) optdata__config__run ;;
      none ) ;;
      * ) printf '%s\n' "${opt_color:+$'\x1b[31m'}[$script_name] Invalid argument to ${opt_color:+$'\x1b[1m'}--config${opt_color:+$'\x1b[22m'}: ${opt_config@Q}. Allowed values are ['auto'], 'edit', 'generate', 'remove', 'none'.${opt_color:+$'\x1b[0m'}" >&2; exit 1 ;;
    esac
  ;;
esac

case $opt_edl_save_paths in
  relative | absolute ) ;;
  * ) printf '%s\n' "${opt_color:+$'\x1b[31m'}[$script_name] Invalid argument to ${opt_color:+$'\x1b[1m'}--edl-save-paths${opt_color:+$'\x1b[22m'}: ${opt_edl_save_paths@Q}. Allowed values are 'relative', 'absolute'.${opt_color:+$'\x1b[0m'}" >&2; exit 1 ;;
esac

declare -- edl_path= edl_name='search_results.edl'

if [[ $opt_edl_save ]]; then
  edl_path=$(dirname -- "$opt_edl_save")
  edl_name=$(basename -- "$opt_edl_save")
fi

if [[ ! $opt_search_term ]]; then
  printf '%s\n' "${opt_color:+$'\x1b[31m'}[$script_name] No search term was specified. Use ${opt_color:+$'\x1b[1m'}-t, --search-term${opt_color:+$'\x1b[22m'} to specify one or more search terms.${opt_color:+$'\x1b[0m'}" >&2
  exit 1
fi

[[ $# -eq 0 ]] && set -- $conf_default_glob

if [[ $# -eq 0 ]]; then
  printf '%s\n' "${opt_color:+$'\x1b[31m'}[$script_name] No files were passed to the script and none matched the default glob ${conf_default_glob@Q}.${opt_color:+$'\x1b[0m'}" >&2
  exit 1
fi

declare -- search_term_re=

declare -- search_term
for search_term in "${opt_search_term[@]}"; do
  [[ ! $opt_regex ]] && search_term="$(<<<"$search_term" sed -E 's/[](){}<>.*?+|^$\/[]/\\&/g')"
  [[ ! $opt_exact_whitespace ]] && search_term="${search_term// /[[:space:]]+}" 
  search_term_re+="$search_term"'|'
done
unset -v search_term

search_term_re="${search_term_re%|}"

declare -- optdata__filenames_only__inv=
[[ ! $opt_filenames_only ]] && optdata__filenames_only__inv=1
declare -- optdata__match_case__inv=
[[ ! $opt_match_case ]] && optdata__match_case__inv=1

declare -- sed_script_cleanup='1 s/^\xef\xbb\xbf//; s/\r$//; s/\s+$//' # Remove byte order mark, carriage returns, and trailing whitespace

declare -A \
  stats_number_subtitles_total \
  stats_number_subtitles_matched \
  stats_number_subtitles_unmatched \
  stats_percentage_subtitles_matched

declare -- had_errors= had_matches=

declare -- lua_bin
type -P 'lua5.4' > /dev/null && lua_bin='lua5.4' || lua_bin='lua'

function generate_edl_line {

  "$lua_bin" <(printf '%s\n' '

    filename = arg[1]
    timecodes_parts = {arg[2]:match("(%d%d):(%d%d):(%d%d),(%d%d%d)%s+%-%->%s+(%d%d):(%d%d):(%d%d),(%d%d%d)")}
    chapter_title = arg[3]
    before, after = string.format("%.3f", arg[4]), string.format("%.3f", arg[5])
    file_duration = arg[6]

    a = timecodes_parts[1] * 3600 + timecodes_parts[2] * 60 + (timecodes_parts[3] .. "." .. timecodes_parts[4]) - before
    b = timecodes_parts[5] * 3600 + timecodes_parts[6] * 60 + (timecodes_parts[7] .. "." .. timecodes_parts[8]) + after

    if a < 0 then a = 0 end
    if file_duration ~= nil and b > tonumber(file_duration) then b = file_duration end

    print(string.format("%%%s%%%s,%s,%s,title=%%%s%%%s", #filename, filename, a, b - a, #chapter_title, chapter_title))

  ') "$1" "$2" "$3" "$opt_edl_play_before" "$opt_edl_play_after" ${4:+"$4"}

}

function calc_segment_length {

  "$lua_bin" <(printf '%s\n' '

    timecodes_parts = {arg[1]:match("(%d%d):(%d%d):(%d%d),(%d%d%d)%s+%-%->%s+(%d%d):(%d%d):(%d%d),(%d%d%d)")}
    before = string.format("%.0f", arg[2] * 1000)
    after = string.format("%.0f", arg[3] * 1000)
    if arg[4] ~= nil then
      file_duration = string.format("%.0f", arg[4] * 1000)
    end

    a = ((timecodes_parts[1] * 3600 + timecodes_parts[2] * 60 + timecodes_parts[3]) .. timecodes_parts[4]) - before
    b = ((timecodes_parts[5] * 3600 + timecodes_parts[6] * 60 + timecodes_parts[7]) .. timecodes_parts[8]) + after

    if a < 0 then a = 0 end
    if file_duration ~= nil and b > tonumber(file_duration) then b = file_duration end

    print(b - a)

  ') "$1" "$opt_edl_play_before" "$opt_edl_play_after" ${2:+"$2"}

}

declare -- cache_dir_edl="$cache_dir"'/edl'

[[ $opt_edl_play && ! $opt_edl_save && ! -d "$cache_dir_edl" ]] && mkdir -p "$cache_dir_edl"

declare -a missing_video_files=()

declare -- chapter_end=0

declare -- i
for (( i = 1; i <= $#; i++ )); do

  [[ -d "${!i}" ]] && set -- "${@:1:$(( i - 1 ))}" "${!i%%+(/)}"/$conf_default_glob "${@:$(( i + 1 ))}"

  video_file_missing=

  if [[ ! -e "${!i}" ]]; then
    printf '%s\n' "${opt_color:+$'\x1b[33m'}[$script_name] File ${!i@Q} does not exist. Skipping.${opt_color:+$'\x1b[0m'}" >&2
    had_errors=1
    shift
    (( i-- ))
    continue
  elif [[ ! -f "${!i}" ]]; then
    printf '%s\n' "${opt_color:+$'\x1b[33m'}[$script_name] ${!i@Q} is not a file. Skipping.${opt_color:+$'\x1b[0m'}" >&2
    had_errors=1
    shift
    (( i-- ))
    continue
  fi

  if [[ $opt_stats ]]; then
    stats_number_subtitles_total[${!i}]=$(sed -nE -e "$sed_script_cleanup" -e '/^[[:digit:]]+$/ p' "${!i}" | wc -l)
    stats_number_subtitles_matched[${!i}]=0
  fi

  if [[ $opt_edl_play || $opt_edl_save ]]; then 

      declare -- video_file subtitle_file

      [[ ${!i} == /* ]] && subtitle_file="${!i}" || subtitle_file="$PWD"'/'"${!i}"

      declare -a candidates=()

      declare -- base="$subtitle_file"
      until [[ ${#candidates[@]} -gt 0 || $base != *.* ]]; do
        base="${base%.*}" candidates=("$base"'.'!(srt|*.srt))
      done
      unset -v base

      declare -a video_files=() audio_files=()

      declare -- candidate
      for candidate in "${candidates[@]}"; do
        declare -- mime_type=$(file --dereference --brief --mime-type -- "$candidate")
        case $mime_type in
          video/* ) video_files+=("$candidate");;
          audio/* ) audio_files+=("$candidate");;
        esac
        unset -v mime_type
      done
      unset -v candidate
      unset -v candidates

      if [[ ${#video_files[@]} -gt 0 ]]; then
        video_file="${video_files[0]}"
      elif [[ ${#audio_files[@]} -gt 0 ]]; then
        video_file="${audio_files[0]}"
      else
        video_file=
      fi
      unset -v video_files audio_files

      declare -- video_file_abs="$video_file"

      video_file_duration=

      if [[ $video_file ]]; then
       
        [[ $opt_edl_play_after != 0 ]] && video_file_duration=$(printf '%.3f' "$(ffprobe -v 'error' -show_entries 'format=duration' -of 'default=noprint_wrappers=1:nokey=1' "$video_file")")

        if [[ $opt_edl_save && $opt_edl_save_paths == 'relative' ]]; then
          video_file=$(realpath --no-symlinks --relative-to="$edl_path" "$video_file")
          subtitle_file=$(realpath --no-symlinks --relative-to="$edl_path" "$subtitle_file")
        fi

      else
        missing_video_files+=("${!i}")
        video_file_missing=1
      fi

  fi

  file_has_matches=

  declare -- subtitle

  while read -rd '' subtitle; do

    had_matches=1
    
    if [[ ($opt_edl_play || \
          $opt_edl_save) && \
          ( \
            ! ($opt_edl_ignore_missing && ${#missing_video_files[@]} -gt 0) || \
            ! $video_file_missing \
          ) ]]; then 
      [[ ${subtitle//$'\x1b['*([^m])'m'/} =~ ^([^$'\n']*)$'\n'*(([^$'\n']*)' --> '([^$'\n']*))$'\n'(([^$'\n']*).*)$ ]]
      declare -A subtitle_data=(
        [file_base]="${video_file##*/}"
        [file_edl]="$video_file"
        [file_rel]="${video_file_abs#$PWD/}"
        [file_abs]="$video_file_abs"
        [n]="${BASH_REMATCH[1]}"
        [timecodes_raw]="${BASH_REMATCH[2]}"
        [timecode_start]="${BASH_REMATCH[3]/,/.}"
        [timecode_start_raw]="${BASH_REMATCH[3]}"
        [timecode_end]="${BASH_REMATCH[4]/,/.}"
        [timecode_end_raw]="${BASH_REMATCH[4]}"
        [text_tall]="${BASH_REMATCH[5]}"
        [text_long]="${BASH_REMATCH[5]//$'\n'/ }"
        [text_abbr]="${BASH_REMATCH[6]}"
      )
      if [[ $conf_chapter_title ]]; then
        chapter_title="$(eval set -- "${subtitle_data[@]@K}"; fstr "$conf_chapter_title" "$@")"
      else
        chapter_title="${subtitle_data[text_abbr]}"
      fi
      chapter_start="$chapter_end"
      chapter_end=$(( chapter_start + $(calc_segment_length "${subtitle_data[timecodes_raw]}" ${video_file_duration:+"$video_file_duration"}) ))
      chapters+=("$(printf '[CHAPTER]\nTIMEBASE=1/1000\nSTART=%s\nEND=%s\ntitle=%s' "$chapter_start" "$chapter_end" "$chapter_title")")
      video_edl_lines+=("$(generate_edl_line "$video_file" "${subtitle_data[timecodes_raw]}" "$chapter_title" ${video_file_duration:+"$video_file_duration"})")
      subtitles_edl_lines+=("$(generate_edl_line "$subtitle_file" "${subtitle_data[timecodes_raw]}" "$chapter_title" ${video_file_duration:+"$video_file_duration"})")
    fi

    [[ $opt_stats ]] && (( stats_number_subtitles_matched[${!i}]++ ))

    [[ ! $opt_quiet && ! $opt_inverse && ! $file_has_matches ]] &&
      printf ${opt_color:+'\x1b[38;5;34m'}'%s'${opt_color:+'\x1b[39m'}'\n'${optdata__filenames_only__inv:+'\n'} "${!i}" 

    file_has_matches=1

    [[ ! $opt_quiet && ! $opt_filenames_only && ! $opt_inverse ]] && printf '%s\n\n' "$subtitle"

  done < <(

    sed -E "$sed_script_cleanup" "${!i}" | sed -nE '

      /^[[:digit:]]+$/ {
        h
        n
        /^[[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2},[[:digit:]]{3} --> [[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2},[[:digit:]]{3}$/ {
          H
          :a $ ! { n; /^$/! { H; b a } }
          g
          s/^([[:digit:]]+\n[[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2},[[:digit:]]{3} --> [[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2},[[:digit:]]{3})\n(.*)$/\1/
          x
          s//\2/
          /'"$search_term_re"'/M'${optdata__match_case__inv:+'I'}' {
            '${opt_color:+"s/$search_term_re/\\x1b[7m&\\x1b[27m/gM${optdata__match_case__inv:+I}"}'
            s/<b>/'${opt_color:+'\x1b[1m'}'/g; s/<\/b>/'${opt_color:+'\x1b[22m'}'/g
            s/<i>/'${opt_color:+'\x1b[3m'}'/g; s/<\/i>/'${opt_color:+'\x1b[23m'}'/g
            s/<u>/'${opt_color:+'\x1b[4m'}'/g; s/<\/u>/'${opt_color:+'\x1b[24m'}'/g
            s/<s>/'${opt_color:+'\x1b[9m'}'/g; s/<\/s>/'${opt_color:+'\x1b[29m'}'/g
            s/<[^>]*>//g
            H
            g
            '${opt_color:+'s/^([[:digit:]]+\n[[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2},[[:digit:]]{3} --> [[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2},[[:digit:]]{3})\n(.*)$/\x1b[2m\1\x1b[22m\n\2/'}'
            s/$/\x00/
            p
          }
        }
      }

    '

  )

  unset -v subtitle

  if [[ ! $opt_quiet && ! $file_has_matches && ( $opt_verbose || $opt_inverse ) ]]; then
    printf ${opt_color:+'\x1b[2m'}'%s'${opt_color:+'\x1b[22m'}'\n' "${!i}" 
    [[ $opt_stats && $i -eq $# ]] && printf '\n'
  fi

  if [[ $opt_stats ]]; then
    stats_number_subtitles_unmatched[${!i}]=$(( stats_number_subtitles_total[${!i}] - stats_number_subtitles_matched[${!i}] ))
    stats_percentage_subtitles_matched[${!i}]=$(printf '%d / %d * 100\n' "${stats_number_subtitles_matched[${!i}]}" "${stats_number_subtitles_total[${!i}]}" | bc -l)
  fi

done
unset -v i

function clear_cache_edl { (shopt -s dotglob; compgen -G "$cache_dir_edl"'/*' > /dev/null && rm -r "$cache_dir_edl"/*) }

if [[ $had_matches && ( $opt_edl_play || $opt_edl_save ) ]]; then

  declare -- missing_video_files_warning missing_video_files_error

  if [[ ${#missing_video_files[@]} -gt 0 ]]; then
    if [[ $opt_edl_ignore_missing ]]; then
      missing_video_files_warning=1 
      [[ ${#missing_video_files[@]} == $# ]] && all_video_files_missing_warning=1
    else
      missing_video_files_error=1
    fi
  fi

  if [[ ! $all_video_files_missing_warning && ! $missing_video_files_error ]]; then

    declare -- edl_dest_dir

    [[ $opt_edl_save ]] && edl_dest_dir="$edl_path" || edl_dest_dir="$cache_dir_edl"

    [[ ! $opt_edl_save ]] && clear_cache_edl

    if [[ $opt_edl_save && \
          ! -d "$edl_dest_dir" ]]; then

      if [[ $opt_edl_save_mkdir ]]; then
        mkdir -p "$edl_dest_dir"
      else
        printf '%s\n' "${opt_color:+$'\x1b[31m'}[$script_name] EDL save directory ${edl_dest_dir@Q} does not exist. Make sure to pass a path to an existing directory, or set -d, --edl-save-mkdir to create a directory automatically.${opt_color:+$'\x1b[0m'}" >&2
        exit 1
      fi

    fi

    edl_main_edl="$edl_dest_dir"'/'"$edl_name"
    edl_chapters_ffmetadata="$edl_dest_dir"'/'"${edl_name%.edl}"'-chapters.ffmetadata'

    if [[ $opt_edl_save && \
          ! $opt_edl_save_overwrite ]]; then

      existing_files=()
      
      for file in "$edl_main_edl" "$edl_chapters_ffmetadata"; do
        [[ -e "$file" ]] && existing_files+=("$file")
      done

      if [[ ${#existing_files[@]} -gt 0 ]]; then
        printf '%s\n' "${opt_color:+$'\x1b[31m'}[$script_name] The following files already exist:" >&2
        printf '%s\n' "${existing_files[@]@Q}" >&2
        printf '%s\n' "Set ${opt_color:+$'\x1b[1m'}-y, --edl-save-overwrite${opt_color:+$'\x1b[22m'} to overwrite.${opt_color:+$'\x1b[39m'}" >&2
        exit 1
      fi

    fi

    unset -v edl_dest_dir

    {

      printf '%s\n' '# mpv EDL v0'
      printf '\n'
      printf '%s\n' '!no_chapters'
      printf '%s\n' "${video_edl_lines[@]}"
      printf '\n'
      printf '%s\n' '!new_stream'
      printf '%s\n' '!no_chapters'
      printf '%s\n' "${subtitles_edl_lines[@]}"

    } > "$edl_main_edl"

    {
    
      printf '%s\n\n' ';FFMETADATA1'
      printf '%s\n\n' "${chapters[@]}"

    } > "$edl_chapters_ffmetadata" 

    [[ $opt_edl_play ]] && play_edl=1

  fi

fi

if [[ $opt_stats ]]; then

  declare -A stats_totals
  
  stats_totals[number_files_matched]=0
  stats_totals[number_files_total]="$#"
  stats_totals[number_files_unmatched]=
  stats_totals[percentage_files_matched]=

  stats_totals[number_subtitles_matched]=0
  stats_totals[number_subtitles_total]=0
  stats_totals[number_subtitles_unmatched]=0
  stats_totals[percentage_subtitles_matched]=

  for file; do

    [[ ${stats_number_subtitles_matched[$file]} -gt 0 ]] && (( stats_totals[number_files_matched]++ ))
    if [[ ${stats_number_subtitles_matched[$file]} ]]; then
      stats_totals[number_subtitles_matched]=$(( stats_totals[number_subtitles_matched] + stats_number_subtitles_matched[$file] ))
    fi
    if [[ ${stats_number_subtitles_total[$file]} ]]; then
      stats_totals[number_subtitles_total]=$(( stats_totals[number_subtitles_total] + stats_number_subtitles_total[$file] ))
    fi
    if [[ ${stats_number_subtitles_unmatched[$file]} ]]; then
      stats_totals[number_subtitles_unmatched]=$(( stats_totals[number_subtitles_unmatched] + stats_number_subtitles_unmatched[$file] ))
    fi

  done

  stats_totals[number_files_unmatched]=$(( stats_totals[number_files_total] - stats_totals[number_files_matched] ))
  if [[ ${stats_totals[number_files_total]} != 0 ]]; then
    stats_totals[percentage_files_matched]=$(printf '%d / %d * 100\n' "${stats_totals[number_files_matched]}" "${stats_totals[number_files_total]}" | bc -l)
  fi

  if [[ ${stats_totals[number_subtitles_total]} != 0 ]]; then
    stats_totals[percentage_subtitles_matched]=$(printf '%d / %d * 100\n' "${stats_totals[number_subtitles_matched]}" "${stats_totals[number_subtitles_total]}" | bc -l)
  fi

  declare -A stats_averages

  stats_averages[number_subtitles_matched]=
  stats_averages[number_subtitles_total]=
  stats_averages[number_subtitles_unmatched]=
  stats_averages[percentage_subtitles_matched]=

  if [[ ${stats_totals[number_files_matched]} != 0 ]]; then
    stats_averages[number_subtitles_matched]=$(( stats_totals[number_subtitles_matched] / stats_totals[number_files_matched] ))
  fi
  if [[ ${stats_totals[number_files_total]} != 0 ]]; then
    stats_averages[number_subtitles_total]=$(( stats_totals[number_subtitles_total] / stats_totals[number_files_total] ))
  fi
  if [[ ${stats_averages[number_subtitles_matched]} ]]; then
    stats_averages[number_subtitles_unmatched]=$(( stats_averages[number_subtitles_total] - stats_averages[number_subtitles_matched] ))
    stats_averages[percentage_subtitles_matched]=$(printf '%d / %d * 100\n' "${stats_averages[number_subtitles_matched]}" "${stats_averages[number_subtitles_total]}" | bc -l)
  fi

  stats_table_contents=() # This array will include most of the contents of the stats table except for the top header, and the last two rows of the table that contain averages and totals.

  declare -A table_headings
  
  if [[ ! $opt_stats_headers_compact ]]; then

    file_number_format_width=7

    if [[ ${#stats_totals[number_files_total]} -gt 6 ]]; then # `6` because, except for the file numbers, the longest string of text that ever appears in the left vertical header of the stats table is 'Average', which is 7 characters long. The subtracted 1 is for the dot that follows the number.
      file_number_format_width=$(( ${#stats_totals[number_files_total]} + 1 ))
    fi

    table_headings[file]='Files'
    table_headings[matched]='Matched'
    table_headings[total]='Total'
    table_headings[unmatched]='Unmatched'
    table_headings[matched_percentage]='Matched %'
    table_headings[average]='Average'

  else

    file_number_format_width=1

    if [[ $opt_stats_headers_file_numbers ]]; then
      file_number_format_width="${#stats_totals[number_files_total]}"
    fi

    table_headings[file]='F'
    table_headings[matched]='M'
    table_headings[total]='T'
    table_headings[unmatched]='U'
    table_headings[matched_percentage]='M%'
    table_headings[average]='A'

  fi
 
  for i in $(seq 1 "$#"); do

    stats_table_contents+=(

      ${opt_stats_headers:+"${opt_stats_headers_file_numbers:+$(
        [[ ! $opt_stats_headers_compact ]] && v="$i"'.' || v="$i"
        printf ${opt_color:+'\x1b[2;48;5;234m'}'%'"$file_number_format_width"'s'${opt_color:+'\x1b[49;22m'} "$v"
      )}"}

      "$(
        v="${!i@Q}"
        if [[ ! $opt_stats_wrap_filenames ]]; then
          [[ ${stats_number_subtitles_matched[${!i}]} != 0 ]] && c=('38;5;34' '39') || c=('2' '22') 
          printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "$v"
        else
          printf '%s' "$v"
        fi
      )"

      "$(
        v="${stats_number_subtitles_matched[${!i}]}"
        [[ $v != 0 ]] && c=('38;5;34' '39') || c=('2' '22')
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "$v"
      )"

      ${opt_color:+$'\x1b[2m'}'/'${opt_color:+$'\x1b[22m'}
      "$(
        v="${stats_number_subtitles_total[${!i}]}"
        [[ $v != 0 ]] && c=('38;5;33' '39') || c=('2' '22')
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "$v"
      )"

      "$(
        v="${stats_number_subtitles_unmatched[${!i}]}"
        [[ $v != 0 ]] && c=('38;5;208' '39') || c=('2' '22')
        printf ${opt_color:+$'\x1b[2m'}'('${opt_color:+'\x1b[2m'}${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'}${opt_color:+$'\x1b[2m'}')'${opt_color:+'\x1b[22m'} "$v"
      )"

      "$(
        v="${stats_percentage_subtitles_matched[${!i}]}"
        [[ $v != 0 ]] && c=('38;5;220' '39') || c=('2' '22')
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%.2f%%'${opt_color:+'\x1b['"${c[1]}"'m'} "$v"
      )"

    )

  done

  printf \
    \
    ${opt_stats_headers:+'%s\t'}'%s\t%s\t%s\t%s\t%s\t%s\n' \
    \
    ${opt_stats_headers:+${opt_color:+$'\x1b[2;48;5;234m'}''} \
      ${opt_stats_headers:+"${table_headings[file]}"} \
      ${opt_stats_headers:+"${table_headings[matched]}"} \
      ${opt_stats_headers:+''} \
      ${opt_stats_headers:+"${table_headings[total]}"} \
      ${opt_stats_headers:+"${table_headings[unmatched]}"} \
      ${opt_stats_headers:+"${table_headings[matched_percentage]}"}${opt_stats_headers:+$'\x1b[49;22m'} \
    \
    "${stats_table_contents[@]}" \
    \
    ${opt_stats_headers:+${opt_color:+$'\x1b[2;48;5;234m'}"$(
      printf '%'"$file_number_format_width"'s' "${table_headings[average]}"
    )"${opt_color:+$'\x1b[49;22m'}} \
      '' \
      "$(
        v="${stats_averages[number_subtitles_matched]}"
        [[ $v != 0 && $v ]] && c=('38;5;34' '39') || c=('2' '22')
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "${v:--}"
      )" \
      ${opt_color:+$'\x1b[2m'}'/'${opt_color:+$'\x1b[22m'} \
      "$(
        v="${stats_averages[number_subtitles_total]}"
        [[ $v != 0 && $v ]] && c=('38;5;33' '39') || c=('2' '22')
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "${v:--}"
      )" \
      "$(
        v="${stats_averages[number_subtitles_unmatched]}"
        [[ $v != 0 && $v ]] && c=('38;5;208' '39') || c=('2' '22')
        printf ${opt_color:+$'\x1b[2m'}'('${opt_color:+'\x1b[2m'}${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'}${opt_color:+$'\x1b[2m'}')'${opt_color:+'\x1b[22m'} "${v:--}"
      )" \
      "$(
        v="${stats_averages[percentage_subtitles_matched]}"
        [[ $v != 0 && $v ]] && c=('38;5;220' '39') || c=('2' '22')
        [[ $v ]] && f='%.2f%%' || f='%s'
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}"$f"${opt_color:+'\x1b['"${c[1]}"'m'} "${v:--}"
      )" \
    \
    ${opt_stats_headers:+${opt_color:+$'\x1b[2;48;5;234m'}"$(
      printf '%'"$file_number_format_width"'s' "${table_headings[total]}"
    )"${opt_color:+$'\x1b[49;22m'}} \
      "$(
        printf \
          '%s %s %s %s %s' \
          "$(
            v="${stats_totals[number_files_matched]}"
            [[ $v != 0 ]] && c=('38;5;34' '39') || c=('2' '22')
            printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "$v"
          )" \
          ${opt_color:+$'\x1b[2m'}'/'${opt_color:+$'\x1b[22m'} \
          "$(
            v="${stats_totals[number_files_total]}"
            [[ $v != 0 ]] && c=('38;5;33' '39') || c=('2' '22')
            printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "$v"
          )" \
          "$(
            v="${stats_totals[number_files_unmatched]}"
            [[ $v != 0 ]] && c=('38;5;208' '39') || c=('2' '22')
            printf ${opt_color:+$'\x1b[2m'}'('${opt_color:+'\x1b[2m'}${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'}${opt_color:+$'\x1b[2m'}')'${opt_color:+'\x1b[22m'} "$v"
          )" \
          "$(
            v="${stats_totals[percentage_files_matched]}"
            [[ $v != 0 && $v ]] && c=('38;5;220' '39') || c=('2' '22')
            [[ $v ]] && f='%.2f%%' || f='%s'
            printf ${opt_color:+'\x1b['"${c[0]}"'m'}"$f"${opt_color:+'\x1b['"${c[1]}"'m'} "${v:--}"
          )"
      )" \
      "$(
        v="${stats_totals[number_subtitles_matched]}"
        [[ $v != 0 ]] && c=('38;5;34' '39') || c=('2' '22')
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "$v"
      )" \
      ${opt_color:+$'\x1b[2m'}'/'${opt_color:+$'\x1b[22m'} \
      "$(
        v="${stats_totals[number_subtitles_total]}"
        [[ $v != 0 ]] && c=('38;5;33' '39') || c=('2' '22')
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "$v"
      )" \
      "$(
        v="${stats_totals[number_subtitles_unmatched]}"
        [[ $v != 0 ]] && c=('38;5;208' '39') || c=('2' '22')
        printf ${opt_color:+$'\x1b[2m'}'('${opt_color:+'\x1b[2m'}${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'}${opt_color:+$'\x1b[2m'}')'${opt_color:+'\x1b[22m'} "$v"
      )" \
      "$(
        v="${stats_totals[percentage_subtitles_matched]}"
        [[ $v != 0 && $v ]] && c=('38;5;220' '39') || c=('2' '22')
        [[ $v ]] && f='%.2f%%' || f='%s'
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}"$f"${opt_color:+'\x1b['"${c[1]}"'m'} "${v:--}"
      )" \
    | \
    COLUMNS="$COLUMNS" column \
      --separator $'\t' \
      --output-separator ${opt_color:+${opt_stats_wrap_filenames:+$'\x1b[0m'}}' '${opt_color:+${opt_stats_wrap_filenames:+$'\x1b[0m'}} \
      --table \
      --table-noheadings \
      --table-columns ${opt_stats_headers:+'#,'}'F,M,/,T,U,%,' \
      ${opt_stats_wrap_filenames:+--table-wrap 'F,'} \
      --table-right 'M,T,U,%,' \
      | \
      sed -E -e '' \
        ${opt_color:+${opt_stats_headers:+-e '
          # Fixing colorization of the left vertical header on lines where no file number is printed.
          s/^ {'"$file_number_format_width"'}/\x1b[2;48;5;234m&\x1b[49;22m/
        '}} \
        | \
        sed -E -e '' \
        ${opt_color:+${opt_stats_wrap_filenames:+-e '
          # Fixing colorization of filenames when wrapping is enabled. Copies ANSI escape sequences from the Matched column.
          1 s/\x1b\[0m//g
          :a
          /^(\x1b\[[[:digit:];]*m[^\x1b]*\x1b\[[[:digit:];]*m\x1b\[0m \x1b\[0m)([^\x1b]*)(\x1b\[0m \x1b\[0m[[:space:]]*\x1b\[)([[:digit:];]*)(m[[:digit:]]*\x1b\[)([[:digit:];]*)(.*)$/ {
            h
            s/^(\x1b\[[[:digit:];]*m[^\x1b]*\x1b\[[[:digit:];]*m\x1b\[0m \x1b\[0m)([^\x1b]*)(\x1b\[0m \x1b\[0m[[:space:]]*\x1b\[)([[:digit:];]*)(m[[:digit:]]*\x1b\[)([[:digit:];]*)(.*)$/\1\x1b[\4m\2\x1b[\6m\3\4\5\6\7/
            x
            s/^(\x1b\[[[:digit:];]*m[^\x1b]*\x1b\[[[:digit:];]*m\x1b\[0m \x1b\[0m)([^\x1b]*)(\x1b\[0m \x1b\[0m[[:space:]]*\x1b\[)([[:digit:];]*)(m[[:digit:]]*\x1b\[)([[:digit:];]*)(.*)$/\4 \6/
            x
            n
            :b
            /^\x1b\[[[:digit:];]*m[[:space:]]*(Average|Total)\x1b\[[[:digit:];]*m\x1b\[0m \x1b\[0m/ {
              n
              b b
            }
            /^(\x1b\[[[:digit:];]*m[^\x1b]*\x1b\[[[:digit:];]*m\x1b\[0m \x1b\[0m)([^\x1b]*)(\x1b\[0m \x1b\[0m[[:space:]]*\x1b\[)([[:digit:];]*)(m[[:digit:]]*\x1b\[)([[:digit:];]*)(.*)$/! {
              G
              s/^(\x1b\[[[:digit:];]*m[^\x1b]*\x1b\[[[:digit:];]*m\x1b\[0m \x1b\[0m)([^\x1b]*)(\x1b\[0m \x1b\[0m.*)\n([[:digit:];]*) ([[:digit:];]*)$/\1\x1b[\4m\2\x1b[5m\3/
              n
              b b
            }
            b a
          }
        '}}

fi

if [[ $had_errors ]]; then
  printf '%s\n' "${opt_color:+$'\x1b[33m'}[$script_name] Some files were not files or did not exist. See output above.${opt_color:+$'\x1b[0m'}" >&2
  exit 1
fi

if [[ ! $had_matches ]]; then
  exit 2
fi

if [[ $missing_video_files_warning ]]; then

  printf '%s\n' "${opt_color:+$'\x1b[33m'}[$script_name] No video files corresponding to the following subtitle files could be identified:" >&2
  printf '%s\n' "${missing_video_files[@]@Q}" >&2
  printf '%s' "${opt_color:+$'\x1b[0m'}" >&2

  if [[ $all_video_files_missing_warning ]]; then
    printf '%s\n' "${opt_color:+$'\x1b[33m'}[$script_name] No EDL files were generated because no video files could be found.${opt_color:+$'\x1b[0m'}" >&2
  fi

fi

if [[ $missing_video_files_error ]]; then
  printf '%s\n' "${opt_color:+$'\x1b[31m'}[$script_name] No video files corresponding to the following subtitle files could be identified:" >&2
  printf '%s\n' "${missing_video_files[@]@Q}" >&2
  printf '%s\n' "Set ${opt_color:+$'\x1b[1m'}-o, --edl-ignore-missing${opt_color:+$'\x1b[22m'} to skip segments with missing video files.${opt_color:+$'\x1b[0m'}" >&2
  exit 3
fi

if [[ $play_edl ]]; then

  mpv "${opt_mpv_opts[@]}" --chapters-file="$edl_chapters_ffmetadata" -- "$edl_main_edl"

  if [[ ! $opt_edl_save && \
        ! $opt_edl_play_keep_temporary ]]; then
    clear_cache_edl
  fi

fi

# vim: set list listchars=tab\:␉· tabstop=2 :
