#!/usr/bin/env bash

# search-in-subs - search for words in subtitle files
# copyright (c) 2024  Alex Rogers (https://github.com/linguisticmind)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

version=0.2.5

script_name="${BASH_SOURCE##*/}"

function re_esc { <<<"$1" sed -E 's/[](){}<>.*?+|^$\/[]/\\&/g'; }

getopt -T > /dev/null
[[ $? != 4 ]] && { printf '[%s] %s\n' "$script_name" 'Enhanced getopt is required to run this script.' >&2; exit 1; }

help='search-in-subs [<options>] -t <search term> ... [<file|dir> ...]

-t, --search-term=<search term>
        Text to search for.

-g, --default-glob=<glob pattern>
        A shell glob pattern to use when no <file|dir> 
        arguments are specified, or when a <file|dir> 
        argument is a directory.

-v, --verbose
        Print the filename even if there were no matches 
        found in that file.

-V, --no-verbose
        Print filenames only for files that had matches.

-i, --inverse
        Only print the names of the files where no matches 
        were found.

-I, --no-inverse
        Do not supress printing of matches and names of the 
        files where matches were found.

-q, --quiet
        Do not print any matches or filenames.

-Q, --no-quiet
        Do not suppress printing of matches or filenames.

-r, --regex
        Use regular expressions instead of fixed strings in 
        <search term>s.

-R, --no-regex
        Use fixed strings instead of regular expressions in 
        <search term>s.

-c, --match-case
        Make the search case-sensitive.

-C, --no-match-case
        Make the search case-insensitive.

-e, --exact-whitespace
        Match whitespace characters exactly as specified in 
        the <search term>.

-E, --no-exact-whitespace
        Treat all whitespace characters the same during 
        search - ignoring the type of whitespace character, 
        and how many of them appear in a sequence.

-s, --stats
        Show match statistics after search.

-S, --no-stats
        Do not show match statistics after search.

-h, --stats-headers
        Show headers in the statistics table.

-H, --stats-no-headers
        Do not show headers in the statistics table.

-m, --stats-headers-compact
        Compactify headers in the statistics table.

-M, --stats-headers-no-compact
        Do not compactify headers in the statistics table.

-n, --stats-headers-file-numbers
        Show file numbers in the headers of the statistics 
        table.

-N, --stats-headers-no-file-numbers
        Do not show file numbers in the headers of the 
        statistics table.

-w, --stats-wrap-filenames
        Wrap filenames in the statistics table.

-W, --stats-no-wrap-filenames
        Do not wrap filenames in the statistics table.

-p, --edl-play
        Play search results in mpv.

-P, --edl-no-play
        Do not play search results in mpv.

-k, --edl-play-keep-temporary
        Keep temporary EDL files that are created to play 
        search results in mpv.

-K, --edl-play-no-keep-temporary
        Do not keep temporary EDL files that are created to 
        play search results in mpv.

-b, --edl-play-before=<value>
        Add a specified amount of time before each segment 
        when generating EDL files.

-a, --edl-play-after=<value>
        Add a specified amount of time after each segment 
        when generating EDL files.

-f, --edl-save-files-relative[={<path>[/]|<path>/<name>.edl|<name>.edl}]

        Save EDL files that use relative paths to refer to 
        source files.

-F, --edl-save-files-absolute[={<path>[/]|<path>/<name>.edl|<name>.edl}]

        Save EDL files that use absolute paths to refer to 
        source files.

--edl-no-save-files
        Do not save EDL files, but generate temporary files 
        instead.

-d, --edl-save-mkdir
        Create the EDL save directory (the <path> value of 
        --edl-save-files-* options) if it does not exist.

-D, --edl-save-no-mkdir
        Do not create the EDL save directory (the <path> 
        value of --edl-save-files-* options) if it does not 
        exist.

-y, --edl-save-overwrite
        Allow overwriting existing files when saving EDL 
        files.

-Y, --edl-save-no-overwrite
        Do not allow overwriting existing files when saving 
        EDL files.

-o, --edl-ignore-missing
        Omit segments with missing videos when generating 
        EDL files.

-O, --edl-no-ignore-missing
        Do not omit segments with missing videos when 
        generating EDL files.

-u, --edl-structure=<value>
        Determines the structure of the set of generated 
        EDL files.

--mpv-opts=[:[:]]<opts>
        Options to mpv player.

--color
        Colorize the output.

--no-color
        Disable colorization of the output.

--help
        Print help.

--version
        Print version information.
'

opts=$(getopt -n "$script_name" -o 't:,g:,v,V,i,I,q,Q,r,R,c,C,e,E,s,S,h,H,m,M,n,N,w,W,p,P,k,K,b:,a:,u:,f::,F::,d,D,y,Y,o,O,' -l 'search-term:,default-glob:,verbose,no-verbose,inverse,no-inverse,quiet,no-quiet,regex,no-regex,match-case,no-match-case,exact-whitespace,no-exact-whitespace,stats,no-stats,stats-headers,stats-no-headers,stats-headers-compact,stats-headers-no-compact,stats-headers-file-numbers,stats-headers-no-file-numbers,stats-wrap-filenames,stats-no-wrap-filenames,edl-play,edl-no-play,edl-play-keep-temporary,edl-play-no-keep-temporary,edl-play-before:,edl-play-after:,edl-structure:,edl-save-files-relative::,edl-save-files-absolute::,edl-no-save-files,edl-save-mkdir,edl-save-no-mkdir,edl-save-overwrite,edl-save-no-overwrite,edl-ignore-missing,edl-no-ignore-missing,mpv-opts:,color,no-color,help,version,' -- "$@")

[[ $? != 0 ]] && exit 1

eval set -- "$opts"

opt_search_term=()
opt_default_glob='*.srt'
opt_verbose=
opt_inverse=
opt_quiet=
opt_regex=
opt_match_case=
opt_exact_whitespace=
opt_stats=
opt_stats_headers=1
opt_stats_headers_compact=
opt_stats_headers_file_numbers=1
opt_stats_wrap_filenames=1
opt_edl_play=
opt_edl_play_keep_temporary=
opt_edl_play_before=0
opt_edl_play_after=0
opt_edl_structure='flat'
unset opt_edl_save_files_relative
unset opt_edl_save_files_absolute
opt_edl_save_mkdir=
opt_edl_save_overwrite=
opt_edl_ignore_missing=1
opt_mpv_opts=()
opt_mpv_opts_append=1
opt_color=1

config_file="${XDG_CONFIG_HOME:-$HOME/.config}"'/search-in-subs/config.bash'
test -f "$config_file" && source "$_"

if [[ ${opt_edl_save_files_relative+_} && ${opt_edl_save_files_absolute+_} ]]; then
  printf \
    ${opt_color:+'\x1b[31m'}'[%s] %s'${opt_color:+'\x1b[39m'}'\n' \
    "$script_name" \
    'Invalid configuration: `opt_edl_save_files_relative` (`-f, --edl-save-files-relative`) and `opt_edl_save_files_absolute` (`-F, --edl-save-files-absolute`) may not be set simultaneously, but both were set in the configuration file ('"${config_file@Q}"'). Please edit the configuration file and adjust the configuration accordingly.' >&2
  exit 1
fi

cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}"'/search-in-subs'
cache_edl_dir="$cache_dir"'/edl'

while true; do
  case $1 in
    -t | --search-term ) opt_search_term+=("$2"); shift 2 ;;
    -g | --default-glob ) opt_default_glob="$2"; shift 2 ;;
    -v | --verbose ) opt_verbose=1; shift ;;
    -V | --no-verbose ) opt_verbose=; shift ;;
    -i | --inverse ) opt_inverse=1; shift ;;
    -I | --no-inverse ) opt_inverse=; shift ;;
    -q | --quiet ) opt_quiet=1; shift ;;
    -Q | --no-quiet ) opt_quiet=; shift ;;
    -r | --regex ) opt_regex=1; shift ;;
    -R | --no-regex ) opt_regex=; shift ;;
    -c | --match-case ) opt_match_case=1; shift ;;
    -C | --no-match-case ) opt_match_case=; shift ;;
    -e | --exact-whitespace ) opt_exact_whitespace=1; shift ;;
    -E | --no-exact-whitespace ) opt_exact_whitespace=; shift ;;
    -s | --stats ) opt_stats=1; shift ;;
    -S | --no-stats ) opt_stats=; shift ;;
    -h | --stats-headers ) opt_stats_headers=1; shift ;;
    -H | --stats-no-headers ) opt_stats_headers=; shift ;;
    -m | --stats-headers-compact ) opt_stats_headers_compact=1; shift ;;
    -M | --stats-headers-no-compact ) opt_stats_headers_compact=; shift ;;
    -n | --stats-headers-file-numbers ) opt_stats_headers_file_numbers=1; shift ;;
    -N | --stats-headers-no-file-numbers ) opt_stats_headers_file_numbers=; shift ;;
    -w | --stats-wrap-filenames ) opt_stats_wrap_filenames=1; shift ;;
    -W | --stats-no-wrap-filenames ) opt_stats_wrap_filenames=; shift ;;
    -p | --edl-play ) opt_edl_play=1; shift ;;
    -P | --edl-no-play ) opt_edl_play=; shift ;;
    -k | --edl-play-keep-temporary ) opt_edl_play_keep_temporary=1; shift ;;
    -K | --edl-play-no-keep-temporary ) opt_edl_play_keep_temporary=; shift ;;
    -b | --edl-play-before ) opt_edl_play_before="$2"; shift 2 ;;
    -a | --edl-play-after ) opt_edl_play_after="$2"; shift 2 ;;
    -u | --edl-structure ) opt_edl_structure="$2"; shift 2 ;;
    -f | --edl-save-files-relative ) opt_edl_save_files_relative="$2"; unset opt_edl_save_files_absolute; shift 2 ;;
    -F | --edl-save-files-absolute ) opt_edl_save_files_absolute="$2"; unset opt_edl_save_files_relative; shift 2 ;;
    --edl-no-save-files ) unset opt_edl_save_files_absolute opt_edl_save_files_relative; shift ;;
    -d | --edl-save-mkdir ) opt_edl_save_mkdir=1; shift ;;
    -D | --edl-save-no-mkdir ) opt_edl_save_mkdir=; shift ;;
    -y | --edl-save-overwrite ) opt_edl_save_overwrite=1; shift ;;
    -Y | --edl-save-no-overwrite ) opt_edl_save_overwrite=; shift ;;
    -o | --edl-ignore-missing ) opt_edl_ignore_missing=1; shift ;;
    -O | --edl-no-ignore-missing ) opt_edl_ignore_missing=; shift ;;
    --mpv-opts )
      [[ $2 =~ ^(:{0,2})(.*)$ ]]
      case ${BASH_REMATCH[1]} in
        : ) opt_mpv_opts_append= ;;
        :: ) opt_mpv_opts_append=1 ;;
      esac
      [[ ! $opt_mpv_opts_append ]] && opt_mpv_opts=()
      while read -rd '' arg; do
        opt_mpv_opts+=("$arg")
      done < <(<<<"${BASH_REMATCH[2]}" xargs printf '%s\0')
      shift 2
    ;;
    --color ) opt_color=1; shift ;;
    --no-color ) opt_color=; shift ;;
    --help ) printf '%s\n' "$help"; exit ;;
    --version ) printf '%s\n' "$version"; exit ;;
    -- ) shift; break ;;
    * ) printf '[%s] %s\n' "$script_name" 'Internal error: unable to parse option `'"$1"'`.' >&2; exit 1 ;;
  esac
done

shopt -s nullglob extglob globstar

edl_name='search_results.edl'

if [[ ${opt_edl_save_files_relative+_} || ${opt_edl_save_files_absolute+_} ]]; then

  edl_save_files="$opt_edl_save_files_relative""$opt_edl_save_files_absolute"

  case $edl_save_files in
    '' )                                                                           ;;
    */*.edl )  edl_path="${edl_save_files%/*}"
               edl_path="${edl_path:-/}"          edl_name="${edl_save_files##*/}" ;;
    *.edl )                                       edl_name="${edl_save_files##*/}" ;;
    !(*.edl) ) edl_path="${edl_save_files%%+(/)}"
               edl_path="${edl_path:-/}"                                           ;;
  esac

  [[ ! $edl_path ]] && edl_path="$PWD"

fi

edl_subdir=
edl_chapters_in_subdir=

case $opt_edl_structure in
  flat ) edl_subdir= edl_chapters_in_subdir=;;
  subdir ) edl_subdir="$edl_name"'.files' edl_chapters_in_subdir=1;;
  subdir_hidden ) edl_subdir='.'"$edl_name"'.files' edl_chapters_in_subdir=1;;
  subdir_except_chapters ) edl_subdir="$edl_name"'.files' edl_chapters_in_subdir=;;
  subdir_hidden_except_chapters ) edl_subdir='.'"$edl_name"'.files' edl_chapters_in_subdir=;;
  * )
    printf \
      ${opt_color:+'\x1b[31m'}'[%s] %s'${opt_color:+'\x1b[39m'}'\n' \
      "$script_name" \
      'Invalid argument to `-u, --edl-structure`: '"${opt_edl_structure@Q}"'. Allowed values are `flat`, `subdir`, `subdir_hidden`, `subdir_except_chapters` and `subdir_hidden_except_chapters`.' >&2
    exit 1
  ;;
esac

if [[ ! $opt_search_term ]]; then
  printf \
    ${opt_color:+'\x1b[31m'}'[%s] %s'${opt_color:+'\x1b[39m'}'\n' \
    "$script_name" \
    'No search term was specified. Use `-t, --search-term` to specify one or more search terms.' >&2
  exit 1
fi

[[ $# == 0 ]] && set -- $opt_default_glob

if [[ $# == 0 ]]; then
  printf \
    ${opt_color:+'\x1b[31m'}'[%s] %s'${opt_color:+'\x1b[39m'}'\n' \
    "$script_name" \
    'No files were passed to the script and none matched the default glob '"${opt_default_glob@Q}"'.' >&2
  exit 1
fi

search_term_re=

for search_term in "${opt_search_term[@]}"; do
  [[ ! $opt_regex ]] && search_term="$(re_esc "$search_term")"
  [[ ! $opt_exact_whitespace ]] && search_term="${search_term// /[[:space:]]+}" 
  search_term_re+="$search_term"'|'
done

search_term_re="${search_term_re%|}"

[[ ! $opt_match_case ]] && case_insensitive=1

sed_script_cleanup='1 s/^\xef\xbb\xbf//; s/\r$//; s/\s+$//' # Remove byte order mark, carriage returns and trailing whitespace

declare -A \
  stats_number_subtitles_total \
  stats_number_subtitles_matched \
  stats_number_subtitles_unmatched \
  stats_percentage_subtitles_matched

had_errors=
had_matches=

type -P 'lua5.4' > /dev/null && lua_bin='lua5.4' || lua_bin='lua'

function generate_edl_line {

  "$lua_bin" \
    <(printf '%s\n' '

      filename = arg[1]
      timecodes_parts = {arg[2]:match("(%d%d):(%d%d):(%d%d),(%d%d%d)%s+%-%->%s+(%d%d):(%d%d):(%d%d),(%d%d%d)")}
      chapter_title = arg[3]
      before, after = string.format("%.3f", arg[4]), string.format("%.3f", arg[5])
      file_duration = arg[6]

      a = timecodes_parts[1] * 3600 + timecodes_parts[2] * 60 + (timecodes_parts[3] .. "." .. timecodes_parts[4]) - before 
      b = timecodes_parts[5] * 3600 + timecodes_parts[6] * 60 + (timecodes_parts[7] .. "." .. timecodes_parts[8]) + after

      if a < 0 then a = 0 end
      if file_duration ~= nil and b > tonumber(file_duration) then b = file_duration end

      print(string.format("%%%s%%%s,%s,%s,title=%%%s%%%s", #filename, filename, a, b - a, #chapter_title, chapter_title))

    ') \
      "$1" "$2" "$3" "$opt_edl_play_before" "$opt_edl_play_after" ${4:+"$4"}

}

function calc_segment_length {

  "$lua_bin" \
    <(printf '%s\n' '

      timecodes_parts = {arg[1]:match("(%d%d):(%d%d):(%d%d),(%d%d%d)%s+%-%->%s+(%d%d):(%d%d):(%d%d),(%d%d%d)")}
      before = string.format("%.0f", arg[2] * 1000) 
      after = string.format("%.0f", arg[3] * 1000)
      if arg[4] ~= nil then
        file_duration = string.format("%.0f", arg[4] * 1000)
      end

      a = ((timecodes_parts[1] * 3600 + timecodes_parts[2] * 60 + timecodes_parts[3]) .. timecodes_parts[4]) - before
      b = ((timecodes_parts[5] * 3600 + timecodes_parts[6] * 60 + timecodes_parts[7]) .. timecodes_parts[8]) + after

      if a < 0 then a = 0 end
      if file_duration ~= nil and b > tonumber(file_duration) then b = file_duration end

      print(b - a)

    ') \
      "$1" "$opt_edl_play_before" "$opt_edl_play_after" ${2:+"$2"}

}

[[ $opt_edl_play && ! (${opt_edl_save_files_relative+_} || ${opt_edl_save_files_absolute+_}) && ! -d "$cache_edl_dir" ]] && mkdir -p "$cache_edl_dir"

missing_video_files=()

chapter_end=0

for (( i=1; i<=$#; i++ )); do

  [[ -d "${!i}" ]] && set -- "${@:1:$((i - 1))}" "${!i%%+(/)}"/$opt_default_glob "${@:$((i + 1))}"

  video_file_missing=

  if [[ ! -e "${!i}" ]]; then
    printf \
      ${opt_color:+'\x1b[33m'}'[%s] %s'${opt_color:+'\x1b[39m'}'\n' \
      "$script_name" \
      'File '"${!i@Q}"' does not exist. Skipping.' >&2
    had_errors=1
    shift
    ((i--))
    continue
  elif [[ ! -f "${!i}" ]]; then
    printf \
      ${opt_color:+'\x1b[33m'}'[%s] %s'${opt_color:+'\x1b[39m'}'\n' \
      "$script_name" \
      "${!i@Q}"' is not a file. Skipping.' >&2
    had_errors=1
    shift
    ((i--))
    continue
  fi

  if [[ $opt_stats ]]; then
    stats_number_subtitles_total[${!i}]=$(sed -nE -e "$sed_script_cleanup" -e '/^[[:digit:]]+$/ p' "${!i}" | wc -l)
    stats_number_subtitles_matched[${!i}]=0
  fi

  if [[ ($opt_edl_play || \
        (${opt_edl_save_files_relative+_} || ${opt_edl_save_files_absolute+_})) ]]; then 

      [[ ${!i} == /* ]] && video_file="${!i}" subtitle_file="${!i}" || video_file="$PWD"'/'"${!i}" subtitle_file="$PWD"'/'"${!i}"

      video_file="${video_file%.srt}"
      video_file="${video_file%.@(aa|aar|ab|abk|ae|ave|af|afr|ak|aka|am|amh|an|arg|ar|ara|as|asm|av|ava|ay|aym|az|aze|ba|bak|be|bel|bg|bul|bh|bih|bi|bis|bm|bam|bn|ben|bo|tib|bod|tib|br|bre|bs|bos|ca|cat|ce|che|ces|cze|ch|cha|co|cos|cr|cre|cs|cze|cu|chu|cv|chv|cy|wel|cym|wel|da|dan|de|ger|deu|ger|dv|div|dz|dzo|ee|ewe|el|gre|ell|gre|en|eng|eo|epo|es|spa|et|est|eu|baq|eus|baq|fa|per|fas|per|ff|ful|fi|fin|fj|fij|fo|fao|fr|fre|fra|fre|fy|fry|ga|gle|gd|gla|gl|glg|gn|grn|gu|guj|gv|glv|ha|hau|he|heb|hi|hin|ho|hmo|hr|hrv|ht|hat|hu|hun|hy|arm|hye|arm|hz|her|ia|ina|id|ind|ie|ile|ig|ibo|ii|iii|ik|ipk|io|ido|is|ice|isl|ice|it|ita|iu|iku|ja|jpn|jv|jav|ka|geo|kat|geo|kg|kon|ki|kik|kj|kua|kk|kaz|kl|kal|km|khm|kn|kan|ko|kor|kr|kau|ks|kas|ku|kur|kv|kom|kw|cor|ky|kir|la|lat|lb|ltz|lg|lug|li|lim|ln|lin|lo|lao|lt|lit|lu|lub|lv|lav|mg|mlg|mh|mah|mi|mao|mk|mac|mkd|mac|ml|mal|mn|mon|mr|mar|mri|mao|ms|may|msa|may|mt|mlt|my|bur|mya|bur|na|nau|nb|nob|nd|nde|ne|nep|ng|ndo|nl|dut|nld|dut|nn|nno|no|nor|nr|nbl|nv|nav|ny|nya|oc|oci|oj|oji|om|orm|or|ori|os|oss|pa|pan|pi|pli|pl|pol|ps|pus|pt|por|qu|que|rm|roh|rn|run|ro|rum|ron|rum|ru|rus|rw|kin|sa|san|sc|srd|sd|snd|se|sme|sg|sag|si|sin|sk|slo|sl|slv|slk|slo|sm|smo|sn|sna|so|som|sq|alb|sqi|alb|sr|srp|ss|ssw|st|sot|su|sun|sv|swe|sw|swa|ta|tam|te|tel|tg|tgk|th|tha|ti|tir|tk|tuk|tl|tgl|tn|tsn|to|ton|tr|tur|ts|tso|tt|tat|tw|twi|ty|tah|ug|uig|uk|ukr|ur|urd|uz|uzb|ve|ven|vi|vie|vo|vol|wa|wln|wo|wol|xh|xho|yi|yid|yo|yor|za|zha|zh|chi|zho|chi|zu|zul)}"

      candidates=("$video_file"!(?(.*).srt))

      video_files=()
      audio_files=()

      for candidate in "${candidates[@]}"; do
        mime_type=$(file --dereference --brief --mime-type "$candidate")
        case $mime_type in
          video/* ) video_files+=("$candidate");;
          audio/* ) audio_files+=("$candidate");;
        esac
      done

      if [[ ${#video_files[@]} -gt 0 ]]; then
        video_file="${video_files[0]}"
      elif [[ ${#audio_files[@]} -gt 0 ]]; then
        video_file="${audio_files[0]}"
      else
        video_file=
      fi

      video_file_duration=

      if [[ $video_file ]]; then
       
        [[ $opt_edl_play_after != 0 ]] && video_file_duration=$(printf '%.3f' "$(ffprobe -v 'error' -show_entries 'format=duration' -of 'default=noprint_wrappers=1:nokey=1' "$video_file")")

        if [[ ${opt_edl_save_files_relative+_} ]]; then
          video_file=$(realpath --no-symlinks --relative-to="$edl_path"${edl_subdir:+/"$edl_subdir"} "$video_file")
          subtitle_file=$(realpath --no-symlinks --relative-to="$edl_path"${edl_subdir:+/"$edl_subdir"} "$subtitle_file")
        fi

      else
        missing_video_files+=("${!i}")
        video_file_missing=1
      fi

  fi

  file_has_matches=

  while read -rd '' subtitle; do

    had_matches=1
    
    if [[ ($opt_edl_play || \
          (${opt_edl_save_files_relative+_} || ${opt_edl_save_files_absolute+_})) && \
          ( \
            ! ($opt_edl_ignore_missing && ${#missing_video_files[@]} -gt 0) || \
            ! $video_file_missing \
          ) ]]; then 
      timecodes=$(<<<"$subtitle" sed -nE '2 { s/\x1b\[[[:digit:];]+m//g; p }')
      chapter_title=$(<<<"$subtitle" sed -nE '3 { s/\x1b\[[[:digit:];]+m//g; p }')
      chapter_start="$chapter_end"
      chapter_end=$((chapter_start + $(calc_segment_length "$timecodes" ${video_file_duration:+"$video_file_duration"})))
      chapters+=("$(printf '[CHAPTER]\nTIMEBASE=1/1000\nSTART=%s\nEND=%s\ntitle=%s' "$chapter_start" "$chapter_end" "$chapter_title")")
      video_edl_lines+=("$(generate_edl_line "$video_file" "$timecodes" "$chapter_title" ${video_file_duration:+"$video_file_duration"})")
      subtitles_edl_lines+=("$(generate_edl_line "$subtitle_file" "$timecodes" "$chapter_title" ${video_file_duration:+"$video_file_duration"})")
    fi

    [[ $opt_stats ]] && ((stats_number_subtitles_matched[${!i}]++))

    [[ ! $opt_quiet && ! $opt_inverse && ! $file_has_matches ]] &&
      printf ${opt_color:+'\x1b[38;5;34m'}'%s'${opt_color:+'\x1b[39m'}'\n\n' "${!i}" 

    file_has_matches=1

    [[ ! $opt_quiet && ! $opt_inverse ]] && printf '%s\n\n' "$subtitle"

  done < <(

    sed -E "$sed_script_cleanup" "${!i}" | sed -nE '

      /^[[:digit:]]+$/ {
        h
        n
        /^[[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2},[[:digit:]]{3} --> [[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2},[[:digit:]]{3}$/ {
          H
          {
            :a
            $ ! {
              n
              H
              /^$/! b a
            }
          }
          x
          s/[^\n]$/\n/
          s/\n+$/\x0/
          h
          s/^([[:digit:]]+\n[[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2},[[:digit:]]{3} --> [[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2},[[:digit:]]{3}).*$/'${opt_color:+'\x1b[2m'}'\1'${opt_color:+'\x1b[22m'}'/
          x
          s/^[[:digit:]]+\n[[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2},[[:digit:]]{3} --> [[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2},[[:digit:]]{3}\n//
          /'"$search_term_re"'/M'${case_insensitive:+'I'}' {
            s/'"$search_term_re"'/'${opt_color:+'\x1b[7m'}'&'${opt_color:+'\x1b[27m'}'/gM'${case_insensitive:+'I'}'
            s/<b>/'${opt_color:+'\x1b[1m'}'/g
            s/<\/b>/'${opt_color:+'\x1b[22m'}'/g
            s/<i>/'${opt_color:+'\x1b[3m'}'/g
            s/<\/i>/'${opt_color:+'\x1b[23m'}'/g
            s/<u>/'${opt_color:+'\x1b[4m'}'/g
            s/<\/u>/'${opt_color:+'\x1b[24m'}'/g
            s/<s>/'${opt_color:+'\x1b[9m'}'/g
            s/<\/s>/'${opt_color:+'\x1b[29m'}'/g
            H
            x
            p
          }
        }
      }

    '

  )

  if [[ ! $opt_quiet && ! $file_has_matches && ( $opt_verbose || $opt_inverse ) ]]; then
    printf ${opt_color:+'\x1b[2m'}'%s'${opt_color:+'\x1b[22m'}'\n' "${!i}" 
    [[ $opt_stats && $i == $# ]] && printf '\n'
  fi

  if [[ $opt_stats ]]; then
    stats_number_subtitles_unmatched[${!i}]=$((${stats_number_subtitles_total[${!i}]} - ${stats_number_subtitles_matched[${!i}]}))
    stats_percentage_subtitles_matched[${!i}]=$(printf '%d / %d * 100\n' "${stats_number_subtitles_matched[${!i}]}" "${stats_number_subtitles_total[${!i}]}" | bc -l)
  fi

done

function clear_cache_edl { (shopt -s dotglob; compgen -G "$cache_edl_dir"'/*' > /dev/null && rm -r "$cache_edl_dir"/*) }

if [[ $had_matches && \
      ($opt_edl_play || \
      (${opt_edl_save_files_relative+_} || ${opt_edl_save_files_absolute+_})) ]]; then

  if [[ ${#missing_video_files[@]} -gt 0 ]]; then
    if [[ $opt_edl_ignore_missing ]]; then
      missing_video_files_warning=1 
      [[ ${#missing_video_files[@]} == $# ]] && all_video_files_missing_warning=1
    else
      missing_video_files_error=1
    fi
  fi

  if [[ ! $all_video_files_missing_warning && ! $missing_video_files_error ]]; then

    [[ ${opt_edl_save_files_relative+_} || ${opt_edl_save_files_absolute+_} ]] && edl_dest_dir="$edl_path" || edl_dest_dir="$cache_edl_dir"

    [[ ! (${opt_edl_save_files_relative+_} || ${opt_edl_save_files_absolute+_}) ]] && clear_cache_edl

    if [[ (${opt_edl_save_files_relative+_} || ${opt_edl_save_files_absolute+_}) && \
          ! -d "$edl_dest_dir" ]]; then

      if [[ $opt_edl_save_mkdir ]]; then
        mkdir -p "$edl_dest_dir"
      else
        printf \
          ${opt_color:+'\x1b[31m'}'[%s] %s'${opt_color:+'\x1b[39m'}'\n' \
          "$script_name" \
          'EDL save directory '"${edl_dest_dir@Q}"' does not exist. Make sure to pass a path to an existing directory, or set `-d, --edl-save-mkdir` to create a directory automatically.' >&2
        exit 1
      fi

    fi

    edl_main_edl="$edl_dest_dir"'/'"$edl_name"
    edl_video_edl="$edl_dest_dir"'/'${edl_subdir:+"$edl_subdir"/}"${edl_name%.edl}"'-video.edl'
    edl_subtitles_edl="$edl_dest_dir"'/'${edl_subdir:+"$edl_subdir"/}"${edl_name%.edl}"'-subtitles.edl'
    edl_chapters_ffmetadata="$edl_dest_dir"'/'${edl_subdir:+${edl_chapters_in_subdir:+"$edl_subdir"/}}"${edl_name%.edl}"'-chapters.ffmetadata'

    if [[ (${opt_edl_save_files_relative+_} || ${opt_edl_save_files_absolute+_}) && \
          ! $opt_edl_save_overwrite ]]; then

      existing_files=()
      
      for file in "$edl_main_edl" ${edl_subdir:+"$edl_dest_dir"/"$edl_subdir"} "$edl_video_edl" "$edl_subtitles_edl" "$edl_chapters_ffmetadata"; do
        [[ -e "$file" ]] && existing_files+=("$file")
      done

      if [[ ${#existing_files[@]} -gt 0 ]]; then
        printf \
          ${opt_color:+'\x1b[31m'}'[%s] %s''\n' \
          "$script_name" \
          'The following files already exist:' >&2
        printf '%s\n' "${existing_files[@]@Q}" >&2
        printf \
          '%s'${opt_color:+'\x1b[39m'}'\n' \
          'Set `-y, --edl-save-overwrite` to overwrite.' >&2
        exit 1
      fi

    fi

    [[ $edl_subdir && ! -d "$edl_dest_dir"'/'"$edl_subdir" ]] && mkdir "$edl_dest_dir"'/'"$edl_subdir"

    {

      printf '%s\n\n' '# mpv EDL v0'
      printf '%s\n' \
        '!no_chapters' \
        "$("$lua_bin" <(printf '%s\n' 'print(string.format("%%%s%%%s", #arg[1], arg[1]))') ${edl_subdir:+"$edl_subdir"/}"${edl_name%.edl}"'-video.edl')" \
        '!new_stream' \
        '!no_chapters' \
        "$("$lua_bin" <(printf '%s\n' 'print(string.format("%%%s%%%s", #arg[1], arg[1]))') ${edl_subdir:+"$edl_subdir"/}"${edl_name%.edl}"'-subtitles.edl')"

    } > "$edl_main_edl"

    {

      printf '%s\n\n' '# mpv EDL v0'
      printf '%s\n' "${video_edl_lines[@]}"

    } > "$edl_video_edl"

    {

      printf '%s\n\n' '# mpv EDL v0'
      printf '%s\n' "${subtitles_edl_lines[@]}"

    } > "$edl_subtitles_edl"
   
    {
    
      printf '%s\n\n' ';FFMETADATA1'
      printf '%s\n\n' "${chapters[@]}"

    } > "$edl_chapters_ffmetadata" 

    [[ $opt_edl_play ]] && play_edl=1

  fi

fi

if [[ $opt_stats ]]; then

  declare -A stats_totals
  
  stats_totals[number_files_matched]=0
  stats_totals[number_files_total]="$#"
  stats_totals[number_files_unmatched]=
  stats_totals[percentage_files_matched]=

  stats_totals[number_subtitles_matched]=0
  stats_totals[number_subtitles_total]=0
  stats_totals[number_subtitles_unmatched]=0
  stats_totals[percentage_subtitles_matched]=

  for file; do

    [[ ${stats_number_subtitles_matched[$file]} -gt 0 ]] && ((stats_totals[number_files_matched]++))
    if [[ ${stats_number_subtitles_matched[$file]} ]]; then
      stats_totals[number_subtitles_matched]=$((${stats_totals[number_subtitles_matched]} + ${stats_number_subtitles_matched[$file]}))
    fi
    if [[ ${stats_number_subtitles_total[$file]} ]]; then
      stats_totals[number_subtitles_total]=$((${stats_totals[number_subtitles_total]} + ${stats_number_subtitles_total[$file]}))
    fi
    if [[ ${stats_number_subtitles_unmatched[$file]} ]]; then
      stats_totals[number_subtitles_unmatched]=$((${stats_totals[number_subtitles_unmatched]} + ${stats_number_subtitles_unmatched[$file]}))
    fi

  done

  stats_totals[number_files_unmatched]=$((${stats_totals[number_files_total]} - ${stats_totals[number_files_matched]}))
  if [[ ${stats_totals[number_files_total]} != 0 ]]; then
    stats_totals[percentage_files_matched]=$(printf '%d / %d * 100\n' "${stats_totals[number_files_matched]}" "${stats_totals[number_files_total]}" | bc -l)
  fi

  if [[ ${stats_totals[number_subtitles_total]} != 0 ]]; then
    stats_totals[percentage_subtitles_matched]=$(printf '%d / %d * 100\n' "${stats_totals[number_subtitles_matched]}" "${stats_totals[number_subtitles_total]}" | bc -l)
  fi

  declare -A stats_averages

  stats_averages[number_subtitles_matched]=
  stats_averages[number_subtitles_total]=
  stats_averages[number_subtitles_unmatched]=
  stats_averages[percentage_subtitles_matched]=

  if [[ ${stats_totals[number_files_matched]} != 0 ]]; then
    stats_averages[number_subtitles_matched]=$((${stats_totals[number_subtitles_matched]} / ${stats_totals[number_files_matched]}))
  fi
  if [[ ${stats_totals[number_files_total]} != 0 ]]; then
    stats_averages[number_subtitles_total]=$((${stats_totals[number_subtitles_total]} / ${stats_totals[number_files_total]}))
  fi
  if [[ ${stats_averages[number_subtitles_matched]} ]]; then
    stats_averages[number_subtitles_unmatched]=$((${stats_averages[number_subtitles_total]} - ${stats_averages[number_subtitles_matched]}))
    stats_averages[percentage_subtitles_matched]=$(printf '%d / %d * 100\n' "${stats_averages[number_subtitles_matched]}" "${stats_averages[number_subtitles_total]}" | bc -l)
  fi

  stats_table_contents=() # This array will include most of the contents of the stats table except for the top header, and the last two rows of the table that contain averages and totals.

  declare -A table_headings
  
  if [[ ! $opt_stats_headers_compact ]]; then

    file_number_format_width=7

    if [[ ${#stats_totals[number_files_total]} -gt 6 ]]; then # `6` because, except for the file numbers, the longest string of text that ever appears in the left vertical header of the stats table is 'Average', which is 7 characters long. The subtracted 1 is for the dot that follows the number.
      file_number_format_width=$((${#stats_totals[number_files_total]} + 1))
    fi

    table_headings[file]='Files'
    table_headings[matched]='Matched'
    table_headings[total]='Total'
    table_headings[unmatched]='Unmatched'
    table_headings[matched_percentage]='Matched %'
    table_headings[average]='Average'

  else

    file_number_format_width=1

    if [[ $opt_stats_headers_file_numbers ]]; then
      file_number_format_width="${#stats_totals[number_files_total]}"
    fi

    table_headings[file]='F'
    table_headings[matched]='M'
    table_headings[total]='T'
    table_headings[unmatched]='U'
    table_headings[matched_percentage]='M%'
    table_headings[average]='A'

  fi
 
  for i in $(seq 1 "$#"); do

    stats_table_contents+=(

      ${opt_stats_headers:+"${opt_stats_headers_file_numbers:+$(
        [[ ! $opt_stats_headers_compact ]] && v="$i"'.' || v="$i"
        printf ${opt_color:+'\x1b[2;48;5;234m'}'%'"$file_number_format_width"'s'${opt_color:+'\x1b[49;22m'} "$v"
      )}"}

      "$(
        v="${!i@Q}"
        if [[ ! $opt_stats_wrap_filenames ]]; then
          [[ ${stats_number_subtitles_matched[${!i}]} != 0 ]] && c=('38;5;34' '39') || c=('2' '22') 
          printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "$v"
        else
          printf '%s' "$v"
        fi
      )"

      "$(
        v="${stats_number_subtitles_matched[${!i}]}"
        [[ $v != 0 ]] && c=('38;5;34' '39') || c=('2' '22')
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "$v"
      )"

      ${opt_color:+$'\x1b[2m'}'/'${opt_color:+$'\x1b[22m'}
      "$(
        v="${stats_number_subtitles_total[${!i}]}"
        [[ $v != 0 ]] && c=('38;5;33' '39') || c=('2' '22')
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "$v"
      )"

      "$(
        v="${stats_number_subtitles_unmatched[${!i}]}"
        [[ $v != 0 ]] && c=('38;5;208' '39') || c=('2' '22')
        printf ${opt_color:+$'\x1b[2m'}'('${opt_color:+'\x1b[2m'}${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'}${opt_color:+$'\x1b[2m'}')'${opt_color:+'\x1b[22m'} "$v"
      )"

      "$(
        v="${stats_percentage_subtitles_matched[${!i}]}"
        [[ $v != 0 ]] && c=('38;5;220' '39') || c=('2' '22')
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%.2f%%'${opt_color:+'\x1b['"${c[1]}"'m'} "$v"
      )"

    )

  done

  printf \
    \
    ${opt_stats_headers:+'%s\t'}'%s\t%s\t%s\t%s\t%s\t%s\n' \
    \
    ${opt_stats_headers:+${opt_color:+$'\x1b[2;48;5;234m'}''} \
      ${opt_stats_headers:+"${table_headings[file]}"} \
      ${opt_stats_headers:+"${table_headings[matched]}"} \
      ${opt_stats_headers:+''} \
      ${opt_stats_headers:+"${table_headings[total]}"} \
      ${opt_stats_headers:+"${table_headings[unmatched]}"} \
      ${opt_stats_headers:+"${table_headings[matched_percentage]}"}${opt_stats_headers:+$'\x1b[49;22m'} \
    \
    "${stats_table_contents[@]}" \
    \
    ${opt_stats_headers:+${opt_color:+$'\x1b[2;48;5;234m'}"$(
      printf '%'"$file_number_format_width"'s' "${table_headings[average]}"
    )"${opt_color:+$'\x1b[49;22m'}} \
      '' \
      "$(
        v="${stats_averages[number_subtitles_matched]}"
        [[ $v != 0 && $v ]] && c=('38;5;34' '39') || c=('2' '22')
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "${v:--}"
      )" \
      ${opt_color:+$'\x1b[2m'}'/'${opt_color:+$'\x1b[22m'} \
      "$(
        v="${stats_averages[number_subtitles_total]}"
        [[ $v != 0 && $v ]] && c=('38;5;33' '39') || c=('2' '22')
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "${v:--}"
      )" \
      "$(
        v="${stats_averages[number_subtitles_unmatched]}"
        [[ $v != 0 && $v ]] && c=('38;5;208' '39') || c=('2' '22')
        printf ${opt_color:+$'\x1b[2m'}'('${opt_color:+'\x1b[2m'}${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'}${opt_color:+$'\x1b[2m'}')'${opt_color:+'\x1b[22m'} "${v:--}"
      )" \
      "$(
        v="${stats_averages[percentage_subtitles_matched]}"
        [[ $v != 0 && $v ]] && c=('38;5;220' '39') || c=('2' '22')
        [[ $v ]] && f='%.2f%%' || f='%s'
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}"$f"${opt_color:+'\x1b['"${c[1]}"'m'} "${v:--}"
      )" \
    \
    ${opt_stats_headers:+${opt_color:+$'\x1b[2;48;5;234m'}"$(
      printf '%'"$file_number_format_width"'s' "${table_headings[total]}"
    )"${opt_color:+$'\x1b[49;22m'}} \
      "$(
        printf \
          '%s %s %s %s %s' \
          "$(
            v="${stats_totals[number_files_matched]}"
            [[ $v != 0 ]] && c=('38;5;34' '39') || c=('2' '22')
            printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "$v"
          )" \
          ${opt_color:+$'\x1b[2m'}'/'${opt_color:+$'\x1b[22m'} \
          "$(
            v="${stats_totals[number_files_total]}"
            [[ $v != 0 ]] && c=('38;5;33' '39') || c=('2' '22')
            printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "$v"
          )" \
          "$(
            v="${stats_totals[number_files_unmatched]}"
            [[ $v != 0 ]] && c=('38;5;208' '39') || c=('2' '22')
            printf ${opt_color:+$'\x1b[2m'}'('${opt_color:+'\x1b[2m'}${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'}${opt_color:+$'\x1b[2m'}')'${opt_color:+'\x1b[22m'} "$v"
          )" \
          "$(
            v="${stats_totals[percentage_files_matched]}"
            [[ $v != 0 && $v ]] && c=('38;5;220' '39') || c=('2' '22')
            [[ $v ]] && f='%.2f%%' || f='%s'
            printf ${opt_color:+'\x1b['"${c[0]}"'m'}"$f"${opt_color:+'\x1b['"${c[1]}"'m'} "${v:--}"
          )"
      )" \
      "$(
        v="${stats_totals[number_subtitles_matched]}"
        [[ $v != 0 ]] && c=('38;5;34' '39') || c=('2' '22')
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "$v"
      )" \
      ${opt_color:+$'\x1b[2m'}'/'${opt_color:+$'\x1b[22m'} \
      "$(
        v="${stats_totals[number_subtitles_total]}"
        [[ $v != 0 ]] && c=('38;5;33' '39') || c=('2' '22')
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'} "$v"
      )" \
      "$(
        v="${stats_totals[number_subtitles_unmatched]}"
        [[ $v != 0 ]] && c=('38;5;208' '39') || c=('2' '22')
        printf ${opt_color:+$'\x1b[2m'}'('${opt_color:+'\x1b[2m'}${opt_color:+'\x1b['"${c[0]}"'m'}'%s'${opt_color:+'\x1b['"${c[1]}"'m'}${opt_color:+$'\x1b[2m'}')'${opt_color:+'\x1b[22m'} "$v"
      )" \
      "$(
        v="${stats_totals[percentage_subtitles_matched]}"
        [[ $v != 0 && $v ]] && c=('38;5;220' '39') || c=('2' '22')
        [[ $v ]] && f='%.2f%%' || f='%s'
        printf ${opt_color:+'\x1b['"${c[0]}"'m'}"$f"${opt_color:+'\x1b['"${c[1]}"'m'} "${v:--}"
      )" \
    | \
    COLUMNS="$COLUMNS" column \
      --separator $'\t' \
      --output-separator ${opt_color:+${opt_stats_wrap_filenames:+$'\x1b[0m'}}' '${opt_color:+${opt_stats_wrap_filenames:+$'\x1b[0m'}} \
      --table \
      --table-noheadings \
      --table-columns ${opt_stats_headers:+'#,'}'F,M,/,T,U,%,' \
      ${opt_stats_wrap_filenames:+--table-wrap 'F,'} \
      --table-right 'M,T,U,%,' \
      | \
      sed -E -e '' \
        ${opt_color:+${opt_stats_headers:+-e '
          # Fixing colorization of the left vertical header on lines where no file number is printed.
          s/^ {'"$file_number_format_width"'}/\x1b[2;48;5;234m&\x1b[49;22m/
        '}} \
        | \
        sed -E -e '' \
        ${opt_color:+${opt_stats_wrap_filenames:+-e '
          # Fixing colorization of filenames when wrapping is enabled. Copies ANSI escape sequences from the Matched column.
          1 s/\x1b\[0m//g
          :a
          /^(\x1b\[[[:digit:];]*m[^\x1b]*\x1b\[[[:digit:];]*m\x1b\[0m \x1b\[0m)([^\x1b]*)(\x1b\[0m \x1b\[0m[[:space:]]*\x1b\[)([[:digit:];]*)(m[[:digit:]]*\x1b\[)([[:digit:];]*)(.*)$/ {
            h
            s/^(\x1b\[[[:digit:];]*m[^\x1b]*\x1b\[[[:digit:];]*m\x1b\[0m \x1b\[0m)([^\x1b]*)(\x1b\[0m \x1b\[0m[[:space:]]*\x1b\[)([[:digit:];]*)(m[[:digit:]]*\x1b\[)([[:digit:];]*)(.*)$/\1\x1b[\4m\2\x1b[\6m\3\4\5\6\7/
            x
            s/^(\x1b\[[[:digit:];]*m[^\x1b]*\x1b\[[[:digit:];]*m\x1b\[0m \x1b\[0m)([^\x1b]*)(\x1b\[0m \x1b\[0m[[:space:]]*\x1b\[)([[:digit:];]*)(m[[:digit:]]*\x1b\[)([[:digit:];]*)(.*)$/\4 \6/
            x
            n
            :b
            /^\x1b\[[[:digit:];]*m[[:space:]]*(Average|Total)\x1b\[[[:digit:];]*m\x1b\[0m \x1b\[0m/ {
              n
              b b
            }
            /^(\x1b\[[[:digit:];]*m[^\x1b]*\x1b\[[[:digit:];]*m\x1b\[0m \x1b\[0m)([^\x1b]*)(\x1b\[0m \x1b\[0m[[:space:]]*\x1b\[)([[:digit:];]*)(m[[:digit:]]*\x1b\[)([[:digit:];]*)(.*)$/! {
              G
              s/^(\x1b\[[[:digit:];]*m[^\x1b]*\x1b\[[[:digit:];]*m\x1b\[0m \x1b\[0m)([^\x1b]*)(\x1b\[0m \x1b\[0m.*)\n([[:digit:];]*) ([[:digit:];]*)$/\1\x1b[\4m\2\x1b[5m\3/
              n
              b b
            }
            b a
          }
        '}}

fi

if [[ $had_errors ]]; then
  printf \
    ${opt_color:+'\x1b[33m'}'[%s] %s'${opt_color:+'\x1b[39m'}'\n' \
    "$script_name" \
    'Some files were not files or did not exist. See output above.' >&2
  exit 1
fi

if [[ ! $had_matches ]]; then
  exit 2
fi

if [[ $missing_video_files_warning ]]; then

  printf \
    ${opt_color:+'\x1b[33m'}'[%s] %s''\n' \
    "$script_name" \
    'No video files corresponding to the following subtitle files could be identified:' >&2
  printf '%s\n' "${missing_video_files[@]@Q}" >&2
  printf ${opt_color:+'\x1b[39m'} >&2

  if [[ $all_video_files_missing_warning ]]; then

    printf \
      ${opt_color:+'\x1b[33m'}'[%s] %s'${opt_color:+'\x1b[39m'}'\n' \
      "$script_name" \
      'No EDL files were generated because no video files could be found.' >&2

  fi

fi

if [[ $missing_video_files_error ]]; then

  printf \
    ${opt_color:+'\x1b[31m'}'[%s] %s''\n' \
    "$script_name" \
    'No video files corresponding to the following subtitle files could be identified:' >&2
  printf '%s\n' "${missing_video_files[@]@Q}" >&2
  printf \
    '%s'${opt_color:+'\x1b[39m'}'\n' \
    'Set `-o, --edl-ignore-missing` to skip segments with missing video files.' >&2
  exit 3

fi

if [[ $play_edl ]]; then

  mpv "${opt_mpv_opts[@]}" --chapters-file="$edl_chapters_ffmetadata" "$edl_main_edl"

  if [[ ! (${opt_edl_save_files_relative+_} || ${opt_edl_save_files_absolute+_}) && \
        ! $opt_edl_play_keep_temporary ]]; then
    clear_cache_edl
  fi

fi
